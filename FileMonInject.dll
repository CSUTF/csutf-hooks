using System; 
using System.Collections.Generic; 
using System.Text; 
using System.Threading; 
using System.Runtime.InteropServices; 
using EasyHook; 
namespace FileMonInject 
{ 
 public class Main : EasyHook.IEntryPoint 
 { 
	 FileMon.FileMonInterface Interface; 
	 //LocalHook CreateFileHook; 
	 LocalHook ExtTextOutHook; //Hooks output Text
	 Stack<String> Queue = new Stack<String>(); 


	public Main( 
		 RemoteHooking.IContext InContext, 
		 String InChannelName) 
	{ 
	// connect to host... 
	 Interface = 
	RemoteHooking.IpcConnectClient<FileMon.FileMonInterface>(InChannelName); 
	
	 //Dont know what this is used for
	 Interface.Ping();

	} 
	 public void Run( 
		 RemoteHooking.IContext InContext, 
		 String InChannelName) 
	 { 
	 // install hook... 
	 try 
	 { 
		 /*
	CreateFileHook = LocalHook.Create( 
	 LocalHook.GetProcAddress("kernel32.dll", "CreateFileW"), 
	 new DCreateFile(CreateFile_Hooked), 
	this); 
	 CreateFileHook.ThreadACL.SetExclusiveACL(new Int32[] { 0 }); 
	 */
		 //Hook name            Maybe Grabs the ddl used
		 ExtTextOutHook = LocalHook.Create(
			 LocalHook.GetProcAddress("gdi32.dll", "ExtTestOutW"),
			 new DExtTextout(ExtTextOut_Hooked), this);

		 ExtTextOutHook.ThreadACL.SetExclusiveACL(new Int32[] { 0 });

	 } 
	 catch (Exception ExtInfo) 
 { 
		 Interface.ReportException(ExtInfo);

		 return;
	 }
	 Interface.IsInstalled(RemoteHooking.GetCurrentProcessId());

	 RemoteHooking.WakeUpProcess();

	 // wait for host process termination...
	 try
	 {
		 while (true)
		 {
			 Thread.Sleep(500);

			 // transmit newly monitored file accesses...
			 if (Queue.Count > 0)
			 {
				 String[] Package = null;

				 lock(Queue)
				 {
					 Package = Queue.ToArray();

					 Queue.Clear();
				 }


				 Interface.OnCreatFile(RemoteHooking.GetCurrentProcessId(), Package);
			 }
			 else
				 Interface.Ping();
		 }
	 }
	 catch
	 {
		 // Ping() will raise an exception if host is unreachable
	 }
	 }

	 [Serializable, StructLayout(LayoutKind.Sequential)]
	 public struct RECT
	 {
		 public int Left;
		 public int Top;
		 public int Right;
		 public int Bottom;

		 public RECT(int left_, int top_, int right_, int bottom_)
		 {
			 Left = left_;
			 Top = top_;
			 Right = right_;
			 Bottom = bottom_;
		 }

		 public int Height{ get{ return Bottom - Top; } }
		 public int Width{ get{ return Right - Left; } }

	 }
	 /* [StructLayout(LayoutKind.Sequential)]
	 public struct RECT
	 {
	 private int _Left;
	 private int _Top;
	 private int _Right;
	 private int _Bottom;
	 }*/



	 [UnmanagedFunctionPointer(CallingConvention.StdCall,
		 CharSet = CharSet.Unicode,
		 SetLastError = true)]
	 delegate bool DExtTextOut(
		 IntPtr hdc,
		 int X,
		 int Y,
		 uint fuOptions,
		 [In] ref RECT lprc,
		 [MarshalAs(UnmanagedType.LPWStr)] string lpString,
		 uint cbCount,
		 [In] IntPtr lpDx);
	 /*IntPtr DCreateFile
	 (String InFileName,
	 UInt32 InDesiredAccess,
	 UInt32 InShareMode,
	 IntPtr InSecurityAttributes,
	 UInt32 InCreationDisposition,
	 UInt32 InFlagsAndAttributes,
	 IntPtr InTemplateFile);*/

	 // just use a P-Invoke implementation to get native API access
	 from C# (this step is not necessary for C++.NET)
		 [DllImport("gdi32.dll",
		 CharSet = CharSet.Unicode,
		 SetLastError = true,
		 CallingConvention = CallingConvention.StdCall)]
	 static extern bool ExtTextOut(
		 IntPtr hdc,
		 int X,
		 int Y,
		 uint fuOptions,
		 [In] ref RECT lprc,
		 [MarshalAs(UnmanagedType.LPWStr)] string lpString,

		 uint cbCount,
		 [In] IntPtr lpDx);
	 /*IntPtr CreateFile String InFileName,
	 UInt32 InDesiredAccess,
	 UInt32 InShareMode,
	 IntPtr InSecurityAttributes,
	 UInt32 InCreationDisposition,
	 UInt32 InFlagsAndAttributes,
	 IntPtr InTemplateFile);*/

	 // this is where we are intercepting all file accesses!
	 static bool ExtTextOut_Hooked(
		 IntPtr hdc,
		 int X,
		 int Y,
		 uint fuOptions,
		 [In] ref RECT lprc,
		 [MarshalAs(UnmanagedType.LPWStr)] string lpString,

		 uint cbCount,
		 [In] IntPtr lpDx)
		 /*IntPtr CreateFile_Hooked(
		 String InFileName,
		 UInt32 InDesiredAccess,
		 UInt32 InShareMode,
		 IntPtr InSecurityAttributes,
		 UInt32 InCreationDisposition,
		 UInt32 InFlagsAndAttributes,
		 IntPtr InTemplateFile)*/
	 {

		 try
		 {
			 Main This = (Main)HookRuntimeInfo.Callback;

			 lock(This.Queue)
			 {

				 //if (lpString == "File")
				 //    lpString = "hello";
				 //This.Queue.Push(lpString);
				 This.Queue.Push("[" +
					 RemoteHooking.GetCurrentProcessId() + ":" +
					 RemoteHooking.GetCurrentThreadId() + "]: \"" +
					 lpString + "\"");

			 }
		 }
		 catch
		 {
			 Console.WriteLine("OOoops");
		 }
		 //Seen this alot in all the hooks ive seen
		 // call original API...
		 return ExtTextOut(
			 hdc,
			 X,
			 Y,
			 fuOptions,
			 ref lprc,
			 lpString,
			 cbCount,
			 lpDx);
		 /*InFileName,
		 InDesiredAccess,
		 InShareMode,
		 InSecurityAttributes,
		 InCreationDisposition,
		 InFlagsAndAttributes,
		 InTemplateFile);*/
	 }
 }
}